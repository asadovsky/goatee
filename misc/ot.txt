http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation
http://www3.ntu.edu.sg/home/czsun/projects/otfaq/#_Toc321146161


Tricky case
-----------
- Client A sends A1: "i0:a" (baseOp: nil)
- Client A sends A2: "i1:b" (baseOp: A1)
- Client B sends B1: "i0:c" (baseOp: A1)
- Client B sends B2: "i1:d" (baseOp: A1)
- Server order: A1, A2, B1, B2

Unless we're careful, "d" will end up after "b".


Basic mechanics
---------------
TODO: The following description is no longer fully accurate.

For a given document, server maintains a log of updates, where each update has
an Op, a ClientId, and a BaseOpId. Server broadcasts each update to all clients
as described below.

Client opens document, gets "initial text" and "initial OpId". Client starts
with no local ops and no updates. Now, client makes local changes; these are
stored as ops with BaseOpId set to the current OpId.

When user makes a change, client:
 - Stores it as a local op with BaseOpId set to the current OpId.
 - Sends it to the server (over socket).

When client receives an update, it:
 - Updates (increases) OpId.
 - Transforms local ops against the update (if the update is from a different
   client).

Note that the client must maintain a queue of local ops that are "ahead" of the
latest OpId sent (acknowledged) by the server. Once the server acknowledges a
local op, that local op can be removed from our local queue, since the server
has now caught up to it. (Not true for undo/redo.)

Note that before broadcasting an update, the server must transform it against
all previous ones. This avoids the situation where client A starts from some
initial text and OpId, but later receives an update (submitted by client B)
whose BaseOpId precedes client A's initial OpId.

Note, there are some tricky race conditions to beware of. For example, when a
client registers with the server, the server sends over the "initial text" and
"initial OpId". Suppose that at the same time, the server receives a new update
from some other client -- the server must be sure to send that update along to
the new client!


Undo/redo support
-----------------
Client must maintain a queue of past ops. On undo, last op in queue is undone,
and is moved to redo queue. For redo, vice versa. Whenever user makes a "normal"
change, the redo queue is wiped.

Note that insert ops are typically one character, but "undo" can actually revert
a whole set of insert ops at once. I.e. the definition of "op" for the purposes
of "undo" need not match the OT definition of "op".
